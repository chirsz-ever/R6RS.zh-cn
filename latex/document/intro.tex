\clearextrapart{概述}

\label{historysection}

程序设计语言的设计不应该是特征的堆砌，而应消除那些需要依赖于多余特征的弱点和局限。Scheme语言证明，极少的表达式构造规则和不加限制的表达式复合方式可以构造出实用而高效的程序设计语言，其灵活性足以支持今天的大部分主流编程模型。

Scheme是最早的像在lambda演算里一样提供了第一级过程的程序设计语言之一，并由此在动态类型的语言中提供了有用的静态作用域规则和块结构的特征。在Lisp的主要方言中，Scheme第一次使过程有别于lambda表达式和符号，为所有变量使用单一的词法环境，在确定运算符的位置时采用与确定运算对象位置一样的方式。Scheme完全依赖过程调用来表示迭代，并以此强调，尾递归过程调用在本质上就是传递参数的goto。Scheme是第一种被广泛使用的，采纳第一级逃逸过程（escape procedure）的程序设计语言，通过第一级逃逸过程可以合成所有已知的顺序控制结构。Scheme的后续版本引入了精确和非精确数的概念，这是CommonLisp语言通用算术功能的扩展。最近，Scheme成为了第一种支持卫生宏（hygienic macro）的程序设计语言，该机制允许我们以一种一致和可靠的方式扩展块结构语言的语法。

\subsection*{指导原则}

To help guide the standardization effort, the editors have adopted a
set of principles, presented below.
Like the Scheme language defined in \rrs{5}~\cite{R5RS}, the language described
in this report is intended to:

\begin{itemize}
\item allow programmers to read each other's code, and allow
  development of portable programs that can be executed in any
  conforming implementation of Scheme;

\item derive its power from simplicity, a small number of generally
  useful core syntactic forms and procedures, and no unnecessary
  restrictions on how they are composed;

\item allow programs to define new procedures and new hygienic
  syntactic forms;

\item support the representation of program source code as data;

\item make procedure calls powerful enough to express any form of
  sequential control, and allow programs to perform non-local control
  operations without the use of global program transformations;

\item allow interesting, purely functional programs to run indefinitely
  without terminating or running out of memory on finite-memory
  machines;

\item allow educators to use the language to teach programming
  effectively, at various levels and with a variety of pedagogical
  approaches; and

\item allow researchers to use the language to explore the design,
  implementation, and semantics of programming languages.
\end{itemize}

In addition, this report is intended to:

\begin{itemize}
\item allow programmers to create and distribute substantial programs
  and libraries, e.g., implementations of Scheme Requests for
  Implementation, that run without
  modification in a variety of Scheme implementations;

\item support procedural, syntactic, and data abstraction more fully
  by allowing programs to define hygiene-bending and hygiene-breaking
  syntactic abstractions and new unique datatypes along with
  procedures and hygienic macros in any scope;

\item allow programmers to rely on a level of automatic run-time type
  and bounds checking sufficient to ensure type safety; and

\item allow implementations to generate efficient code, without
  requiring programmers to use implementation-specific operators or
  declarations.
\end{itemize}

While it was possible to write portable programs in Scheme as
described in \rrs{5}, and indeed portable Scheme programs were written
prior to this report, many Scheme programs were not, primarily because
of the lack of substantial standardized libraries and the
proliferation of implementation-specific language additions.

In general, Scheme should include building blocks that allow a wide
variety of libraries to be written, include commonly used user-level
features to enhance portability and readability of library and
application code, and exclude features that are less commonly used and
easily implemented in separate libraries.

The language described in this report is intended to also be backward
compatible with programs written in Scheme as described in \rrs{5} to
the extent possible without compromising the above principles and
future viability of the language.  With respect to future viability,
the editors have operated under the assumption that many more Scheme
programs will be written in the future than exist in the present, so
the future programs are those with which we should be most concerned.

\subsection*{Acknowledgements}

Many people contributed significant help to this revision of the
report.  Specifically, we thank Aziz Ghuloum and Andr\'e van Tonder for
contributing reference implementations of the library system.  We
thank Alan Bawden, John Cowan, Sebastian Egner, Aubrey Jaffer, Shiro
Kawai, Bradley Lucier, and Andr\'e van Tonder for contributing insights on
language design.  Marc Feeley, Martin Gasbichler, Aubrey Jaffer, Lars T Hansen,
Richard Kelsey, Olin Shivers, and Andr\'e van Tonder wrote SRFIs that
served as direct input to the report.  Marcus Crestani, David Frese,
Aziz Ghuloum, Arthur A.\ Gleckler, Eric Knauel, Jonathan Rees, and Andr\'e
van Tonder thoroughly proofread early versions of the report.

We would also like to thank the following people for their
help in creating this report: Lauri Alanko,
Eli Barzilay, Alan Bawden, Brian C.\ Barnes, Per Bothner, Trent Buck,
Thomas Bushnell, Taylor Campbell, Ludovic Court\`es, Pascal Costanza,
John Cowan, Ray Dillinger, Jed Davis, J.A.\ ``Biep'' Durieux, Carl Eastlund,
Sebastian Egner, Tom Emerson, Marc Feeley, Matthias Felleisen, Andy
Freeman, Ken Friedenbach, Martin Gasbichler, Arthur A.\ Gleckler, Aziz
Ghuloum, Dave Gurnell, Lars T Hansen, Ben Harris, Sven Hartrumpf, Dave
Herman, Nils M.\ Holm, Stanislav Ievlev, James Jackson, Aubrey Jaffer,
Shiro Kawai, Alexander Kjeldaas, Eric Knauel, Michael Lenaghan, Felix Klock,
Donovan Kolbly, Marcin Kowalczyk, Thomas Lord, Bradley Lucier, Paulo
J.\ Matos, Dan Muresan, Ryan Newton, Jason Orendorff, Erich Rast, Jeff
Read, Jonathan Rees, Jorgen Sch\"afer, Paul Schlie, Manuel Serrano,
Olin Shivers, Jonathan Shapiro, Jens Axel S\o{}gaard, Jay Sulzberger,
Pinku Surana, Mikael Tillenius, Sam Tobin-Hochstadt, David Van Horn,
Andr\'e van Tonder, Reinder Verlinde, Alan Watson, Andrew Wilcox, Jon
Wilson, Lynn Winebarger, Keith Wright, and Chongkai Zhu.

We would like to thank the following people for their help in creating
the previous revisions of this report: Alan Bawden, Michael
Blair, George Carrette, Andy Cromarty, Pavel Curtis, Jeff Dalton, Olivier Danvy,
Ken Dickey, Bruce Duba, Marc Feeley,
Andy Freeman, Richard Gabriel, Yekta G\"ursel, Ken Haase, Robert
Hieb, Paul Hudak, Morry Katz, Chris Lindblad, Mark Meyer, Jim Miller, Jim Philbin,
John Ramsdell, Mike Shaff, Jonathan Shapiro, Julie Sussman,
Perry Wagle, Daniel Weise, Henry Wu, and Ozan Yigit.

We thank Carol Fessenden, Daniel
Friedman, and Christopher Haynes for permission to use text from the Scheme 311
version 4 reference manual.  We thank Texas Instruments, Inc.~for permission to
use text from the {\em TI Scheme Language Reference Manual}~\cite{TImanual85}.
We gladly acknowledge the influence of manuals for MIT Scheme~\cite{MITScheme},
T~\cite{Rees84}, Scheme 84~\cite{Scheme84}, Common Lisp~\cite{CLtL},
Chez Scheme~\cite{csug7}, PLT~Scheme~\cite{mzscheme352},
and Algol 60~\cite{Naur63}.

\vest We also thank Betty Dexter for the extreme effort she put into
setting this report in \TeX, and Donald Knuth for designing the program
that caused her troubles.

\vest The Artificial Intelligence Laboratory of the
Massachusetts Institute of Technology, the Computer Science
Department of Indiana University, the Computer and Information
Sciences Department of the University of Oregon, and the NEC Research
Institute supported the preparation of this report.  Support for the MIT
work was provided in part by
the Advanced Research Projects Agency of the Department of Defense under Office
of Naval Research contract N00014-80-C-0505.  Support for the Indiana
University work was provided by NSF grants NCS 83-04567 and NCS
83-03325.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "r6rs"
%%% End:
