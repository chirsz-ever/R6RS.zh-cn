\chapter{Scheme概论}
\label{semanticchapter}

本章概述了Scheme的语义。此概述的目的在于充分解释语言的基本概念，以帮助理解本报告的后面的章节，这些章节以参考手册的形式被组织起来。因此，本概述不是本语言的完整介绍，在某些方面也不够精确和规范。

\vest 像Algol语言一样，Scheme是一种静态作用域的程序设计语言。对变量的每一次使用都对应于该变量在词法上的一个明显的绑定。

\vest Scheme中采用的是隐式类型而非显式类型\cite{WaiteGoos}。类型与对象
\mainindex{object 对象}（也称值）相关联，而非与变量相关联。（一些作者将隐式类型的语言称为弱类型或动态类型的语言。）其它采用隐式类型的语言有Python, Ruby, Smalltalk和Lisp的其他方言。采用显式类型的语言（有时被称为强类型或静态类型的语言）包括Algol 60, C, C#, Java, Haskell和ML。

\vest 在Scheme计算过程中创建的所有对象，包括过程和继续（continuation），都拥有无限的生存期（extent）。Scheme对象从不被销毁。Scheme的实现（通常！）不会耗尽空间的原因是，如果它们能证明某个对象无论如何都不会与未来的任何计算发生关联，它们就可以回收该对象占据的空间。其他允许多数对象拥有无限生存期的语言包括C#, Java, Haskell, 大部分Lisp方言, ML, Python, Ruby和Smalltalk。

Scheme的实现必须支持严格尾递归。这一机制允许迭代计算在常量空间内执行，即便该迭代计算在语法上是用递归过程描述的。借助严格尾递归的实现，迭代就可以用普通的过程调用机制来表示，这样一来，专用的迭代结构就只剩下语法糖衣的用途了。


\vest Scheme是最早支持把过程在本质上当作对象的语言之一。过程可以动态创建，可以存储于数据结构中，可以作为过程的结果返回，等等。其他拥有这些特性的语言包括Common Lisp, Haskell, ML, Ruby和Smalltalk。

\vest 在大多数其他语言中只在幕后起作用的继续，在Scheme中也拥有“第一级”状态，这是Scheme的一个独树一帜的特征。第一级继续可用于实现大量不同的高级控制结构，如非局部退出（non-local exits）、回溯（backtracking）和协作程序（coroutine）等。

在Scheme中，过程的参数表达式会在过程获得控制权之前被求值，无论这个过程需不需要这个值。C, C#, Common Lisp, Python, Ruby和Smalltalk是另外几个总在调用过程之前对参数表达式进行求值的语言。这和Haskell惰性求值（lazy-evaluation）的语义以及Algol 60按名求值（call-by-name）的语义不同，在这些语义中，参数表达式只有在过程需要这个值的时候才会被求值。

Scheme的算术模型被设计为尽量独立于计算机内数值的特定表示方式。此外，他
还区分\textit{精确}数和\textit{非精确}数对象：本质上，一个精确数对象精确地等价于一个数，一个非精确数对象是一个涉及到近似或其它误差的计算结果。

\section{基本类型}

Scheme程序操作\textit{对象（object）}，有时也被成为\textit{值（value）}。Scheme对象被组织为叫做\textit{类型（type）}的值的集合。本节将给你Scheme语言十分重要的类型的一个概述。更多的类型将在后面章节进行描述。

\begin{note}
  由于Scheme采用隐式类型，所以本报告中术语\textit{类型}的使用与其它语言文本中本术语的使用不同，尤其是与那些显式语言中的不同。
\end{note}

\paragraph{布尔（Booleans）}

\mainindex{boolean 布尔}布尔类型是一个真值，可以是真或假。在Scheme中，对象“假”被写作`\schfalse{}。对象“真”被写作\schtrue{}。然而，在大部分需要一个真值的情况下，凡是不同于\schfalse{}的对象被看作真。

\paragraph{数值（Numbers）}

\mainindex{number 数值}Scheme广泛支持各类数值数据结构，包括任意精度的整数，有理数，复数和各种类型的非精确数。第~\ref{numbertypeschapter}章给了Scheme数值塔结构的概述。

\paragraph{字符（Characters）}

\mainindex{character 字符}Scheme字符多半等价于一个文本字符。更精确地说，它们同构与Unicode字符编码标准的\textit{标量值（scalar values）}。

\paragraph{字符串（Strings）}

\mainindex{string 字符串}字符串是确定长度字符的有限序列，因此它代表任意的Unicode文本。

\paragraph{符号（Symbols）}

\mainindex{symbol 符号}符号是一个表示为字符串的对象，即它的\textit{名字}。不同于字符串，两个名字拼写一样的符号永远无法区分。符号在许多应用中十分有用；比如：它们可以像其它语言中枚举值那样使用。

\paragraph{点对（Pairs）和表（lists）}

\mainindex{pair 点对}\mainindex{list 表}一个点对是两个元素的数据结构。点对最常用的用法是（逐一串联地）表示表，在这种表结构中，第一个元素（即“car”）表示表的第一个元素，第二个元素（即“cdr”）表示表的剩余部分。Scheme还有一个著名的空表，它是表中一串点对的最后一个cdr。

\paragraph{向量（Vectors）}

\mainindex{vector 向量}像表一样，向量是任意对象有限序列的线性数据结构。然而，表的元素循环地通过链式的点对进行访问，向量的元素通过整数索引进行标识。所以，比起表，向量更适合做元素的随机访问。

\paragraph{过程（Procedures）}

\mainindex{procedure 过程}在Scheme中过程是值。

\section{表达式（Expressions）}

Scheme代码中最重要的元素是\textit{表达式}。表达式可以被\textit{计算（evaluated）}，产生一个\textit{值（value）}。（实际上，是任意数量的值—参见~\ref{multiplereturnvaluessection}节。）最基本的表达式就是字面的表达式：

\begin{scheme}
\schtrue{} \ev \schtrue
23 \ev 23%
\end{scheme}

这表明表达式\schtrue{}的结果就是\schtrue，也就是“真”的值，同时，表达式
{\cf 23}计算得出一个表示数字23的对象。

复合表达式通过在子表达式周围放置小括号来组合。第一个子表达式表示一个运算；剩余的子表达式是运算的操作数：
%
\begin{scheme}
(+ 23 42) \ev 65
(+ 14 (* 23 42)) \ev 980%
\end{scheme}
%

上面例子中的第一个例子，{\cf +}是内置的表示加法的运算的名字，{\cf 23}
和{\cf 42}是操作数。表达式{\cf (+ 23 42)}读作“23和42的和”。复合表达式可以被嵌套—第二个例子读作“14和23和42的积的和”。

正如这些例子所展示的，Scheme中的复合表达式使用相同的前缀表示法
\mainindex{prefix notation 前缀表示法}书写。所以，括号在表达这种结构的时候是必要的。所以，在数学表示和大部分语言中允许的“多余的”括号在Scheme中是不被允许的。

正如其它许多语言，空白符（包括换行符）在表达式中分隔子表达式的时候不是
很重要，它也可以用来表示结构。

\section{变量和绑定（binding）}

\mainindex{variable 变量}\mainindex{binding 绑定}\mainindex{identifier
标识符}Scheme允许标识符代表一个包含值得位置。这些标识符叫做变量。在许多情况下，尤其是这个位置的值在创建之后再也不被修改的时候，认为变量直接代表这个值是非常有用的。

\begin{scheme}
(let ((x 23)
      (y 42))
  (+ x y)) \ev 65%
\end{scheme}

在这种情况下，以{\cf let}开头的表达式是一种绑定结构。跟在{\cf let}之后
的括号结构列出了和表达式一起的变量：和23一起的变量{\cf x}，以及和42一
起的变量{\cf y}。{\cf let}表达式将{\cf x}绑定到{\cf 23}，将{\cf y}绑定
到{\cf 42}。这些绑定在{\cf let}表达式的\textit{内部（body）}是有效的，如上面的{\cf (+ x y)}，也仅仅在那是有效的。

\section{定义}

\index{definition 定义}{\cf let}表达式绑定的变量是\textit{局部的（local）}，因为绑定只在{\cf let}的内部可见。Scheme同样允许创建标识符的顶层绑定，方法如下：

\begin{scheme}
(define x 23)
(define y 42)
(+ x y) \ev 65%
\end{scheme}

（这些实际上是在顶层程序或库的内部的“顶层”；参见下面的~\ref{librariesintrosection}节。）

开始的两个括号结构是*定义*，它们创造了顶层的绑定，绑定`x`到23，绑定`y`到42。定义不是表达式，它不能出现在所有需要一个表达式出现的地方。而且，定义没有值。

绑定遵从程序的词法结构：当存在相同名字的绑定的时候，一个变量参考离它最近的绑定，从它出现的地方开始，并且以从内而外的方式进行，如果在沿途没有发现局部绑定的话就使用顶层绑定：

The first two parenthesized structures are \textit{definitions}; they
create top-level bindings, binding {\cf x} to 23 and {\cf y} to 42.
Definitions are not expressions, and cannot appear in all places
where an expression can occur.  Moreover, a definition has no value.

Bindings follow the lexical structure of the program:  When several
bindings with the same name exist, a variable refers to the binding
that is closest to it, starting with its occurrence in the program
and going from inside to outside, and referring to a top-level
binding if no
local binding can be found along the way:

\begin{scheme}
(define x 23)
(define y 42)
(let ((y 43))
  (+ x y)) \ev 66

(let ((y 43))
  (let ((y 44))
    (+ x y))) \ev 67%
\end{scheme}

\section{Forms}

While definitions are not expressions, compound expressions and
definitions exhibit similar syntactic structure:
%
\begin{scheme}
(define x 23)
(* x 2)%
\end{scheme}
%
While the first line contains a definition, and the second an
expression, this distinction depends on the bindings for {\cf define}
and {\cf *}.  At the purely syntactical level, both are
\textit{forms}\index{form}, and \textit{form} is the general name for
a syntactic part of a Scheme program.  In particular, {\cf 23} is a
\textit{subform}\index{subform} of the form {\cf (define x 23)}.

\section{Procedures}
\label{proceduressection}

\index{procedure}Definitions can also be used to define
procedures:

\begin{scheme}
(define (f x)
  (+ x 42))

(f 23) \ev 65%
\end{scheme}

A procedure is, slightly simplified, an abstraction of an
expression over objects.  In the example, the first definition defines a procedure
called {\cf f}.  (Note the parentheses around {\cf f x}, which
indicate that this is a procedure definition.)  The expression {\cf (f
  23)} is a \index{procedure call}procedure call, meaning,
roughly, ``evaluate {\cf (+ x 42)} (the body of the procedure) with
{\cf x} bound to 23''.

As procedures are objects, they can be passed to other
procedures:
%
\begin{scheme}
(define (f x)
  (+ x 42))

(define (g p x)
  (p x))

(g f 23) \ev 65%
\end{scheme}

In this example, the body of {\cf g} is evaluated with {\cf p}
bound to {\cf f} and {\cf x} bound to 23, which is equivalent
to {\cf (f 23)}, which evaluates to 65.

In fact, many predefined operations of Scheme are provided not by
syntax, but by variables whose values are procedures.
The {\cf +} operation, for example, which receives
special syntactic treatment in many other languages, is just a regular
identifier in Scheme, bound to a procedure that adds number objects.  The
same holds for {\cf *} and many others:

\begin{scheme}
(define (h op x y)
  (op x y))

(h + 23 42) \ev 65
(h * 23 42) \ev 966%
\end{scheme}

Procedure definitions are not the only way to create procedures.  A
{\cf lambda} expression creates a new procedure as an object, with no
need to specify a name:

\begin{scheme}
((lambda (x) (+ x 42)) 23) \ev 65%
\end{scheme}

The entire expression in this example is a procedure call; {\cf
  (lambda (x) (+ x 42))}, evaluates to a procedure that takes a single
number object and adds 42 to it.

\section{Procedure calls and syntactic keywords}

Whereas {\cf (+ 23 42)}, {\cf (f 23)}, and {\cf ((lambda (x) (+ x 42))
  23)} are all examples of procedure calls, {\cf lambda} and {\cf
  let} expressions are not.  This is because {\cf let}, even though
it is an identifier, is not a variable, but is instead a \textit{syntactic
  keyword}\index{syntactic keyword}.  A form that has a
syntactic keyword as its first subexpression obeys special rules determined by
the keyword.  The {\cf define} identifier in a definition is also a
syntactic keyword.  Hence, definitions are also not procedure calls.

The rules for the {\cf lambda} keyword specify that the first
subform is a list of parameters, and the remaining subforms are the body of
the procedure.  In {\cf let} expressions, the first subform is a list
of binding specifications, and the remaining subforms constitute a body of
expressions.

Procedure calls can generally be distinguished from these
\textit{special forms}\mainindex{special form} by
looking for a syntactic keyword in the first position of an
form: if the first position does not contain a syntactic keyword, the expression
is a procedure call.
(So-called \textit{identifier macros} allow creating other kinds of
special forms, but are comparatively rare.)
The set of syntactic keywords of Scheme is
fairly small, which usually makes this task fairly simple.
It is possible, however, to create new bindings for syntactic keywords; see
section~\ref{macrosintrosection} below.

\section{Assignment}

Scheme variables bound by definitions or {\cf let} or {\cf lambda}
expressions are not actually bound directly to the objects specified in the
respective bindings, but to locations containing these objects.  The
contents of these locations can subsequently be modified destructively
via \textit{assignment}\index{assignment}:
%
\begin{scheme}
(let ((x 23))
  (set! x 42)
  x) \ev 42%
\end{scheme}

In this case, the body of the {\cf let} expression consists of two
expressions which are evaluated sequentially, with the value of the
final expression becoming the value of the entire {\cf let}
expression.  The expression {\cf (set! x 42)} is an assignment, saying
``replace the object in the location referenced by {\cf x} with 42''.
Thus, the previous value of {\cf x}, 23, is replaced by 42.

\section{Derived forms and macros}
\label{macrosintrosection}

Many of the special forms specified in this report
can be translated into more basic special forms.
For example, a {\cf let} expression can be translated
into a procedure call and a {\cf lambda} expression.  The following two
expressions are equivalent:
%
\begin{scheme}
(let ((x 23)
      (y 42))
  (+ x y)) \ev 65

((lambda (x y) (+ x y)) 23 42) \lev 65%
\end{scheme}

Special forms like {\cf let} expressions are called \textit{derived
  forms}\index{derived form} because their semantics can be
derived from that of other kinds of forms by a syntactic
transformation.  Some procedure definitions are also derived forms.  The
following two definitions are equivalent:

\begin{scheme}
(define (f x)
  (+ x 42))

(define f
  (lambda (x)
    (+ x 42)))%
\end{scheme}

In Scheme, it is possible for a program to create its own derived
forms by binding syntactic keywords to macros\index{macro}:

\begin{scheme}
(define-syntax def
  (syntax-rules ()
    ((def f (p ...) body)
     (define (f p ...)
       body))))

(def f (x)
  (+ x 42))%
\end{scheme}

The {\cf define-syntax} construct specifies that a parenthesized
structure matching the pattern {\cf (def f (p ...) body)}, where {\cf
  f}, {\cf p}, and {\cf body} are pattern variables, is translated to
{\cf (define (f p ...) body)}.  Thus, the {\cf def} form appearing in
the example gets translated to:

\begin{scheme}
(define (f x)
  (+ x 42))%
\end{scheme}

The ability to create new syntactic keywords makes Scheme extremely
flexible and expressive, allowing many of the features
built into other languages to be derived forms in Scheme.

\section{Syntactic data and datum values}

A subset of the Scheme objects is called \textit{datum
  values}\index{datum value}.
These include booleans, number objects, characters, symbols,
and strings as well as lists and vectors whose elements are data.  Each
datum value may be represented in textual form as a
\textit{syntactic datum}\index{syntactic datum}, which can be written out
and read back in without loss of information.
A datum value may be represented by several different syntactic data.
Moreover, each datum value
can be trivially translated to a literal expression in a program by
prepending a {\cf\singlequote} to a corresponding syntactic datum:

\begin{scheme}
'23 \ev 23
'\schtrue{} \ev \schtrue{}
'foo \ev foo
'(1 2 3) \ev (1 2 3)
'\#(1 2 3) \ev \#(1 2 3)%
\end{scheme}

The {\cf\singlequote} shown in the previous examples
is not needed for representations of number objects or booleans.
The syntactic datum {\cf foo} represents a
symbol with name ``foo'', and {\cf 'foo} is a literal expression with
that symbol as its value.  {\cf (1 2 3)} is a syntactic datum that
represents a list with elements 1, 2, and 3, and {\cf '(1 2 3)} is a literal
expression with this list as its value.  Likewise, {\cf \#(1 2 3)}
is a syntactic datum that represents a vector with elements 1, 2 and 3, and
{\cf '\#(1 2 3)} is the corresponding literal.

The syntactic data are a superset of the Scheme forms.  Thus, data
can be used to represent Scheme forms as data objects.  In
particular, symbols can be used to represent identifiers.

\begin{scheme}
'(+ 23 42) \ev (+ 23 42)
'(define (f x) (+ x 42)) \lev (define (f x) (+ x 42))%
\end{scheme}

This facilitates writing programs that operate on Scheme source code,
in particular interpreters and program transformers.

\section{Continuations}

Whenever a Scheme expression is evaluated there is a
\textit{continuation}\index{continuation} wanting the result of the
expression.  The continuation represents an entire (default) future
for the computation.  For example, informally the continuation of {\cf 3}
in the expression
%
\begin{scheme}
(+ 1 3)%
\end{scheme}
%
adds 1 to it.  Normally these ubiquitous continuations are hidden
behind the scenes and programmers do not think much about them.  On
rare occasions, however, a programmer may need to deal with
continuations explicitly.  The {\cf call-with-current-continuation}
procedure (see section~\ref{call-with-current-continuation}) allows
Scheme programmers to do that by creating a procedure that reinstates
the current continuation.  The {\cf call-with-current-continuation}
procedure accepts a procedure, calls it immediately with an argument
that is an \textit{escape procedure}\index{escape procedure}.  This
escape procedure can then be called with an argument that becomes the
result of the call to {\cf call-with-current-continuation}.  That is,
the escape procedure abandons its own continuation, and reinstates the
continuation of the call to {\cf call-with-current-continuation}.

In the following example, an escape procedure representing the
continuation that adds 1 to its argument is bound to {\cf escape}, and
then called with 3 as an argument.  The continuation of the call to
{\cf escape} is abandoned, and instead the 3 is passed to the
continuation that adds 1:
%
\begin{scheme}
(+ 1 (call-with-current-continuation
       (lambda (escape)
         (+ 2 (escape 3))))) \lev 4%
\end{scheme}
%
An escape procedure has unlimited extent: It can be called after the
continuation it captured has been invoked, and it can be called
multiple times.  This makes {\cf call-with-current-continuation}
significantly more powerful than typical non-local control constructs
such as exceptions in other languages.

\section{Libraries}
\label{librariesintrosection}

Scheme code can be organized in components called
\textit{libraries}\index{library}.  Each library contains
definitions and expressions.  It can import definitions
from other libraries and export definitions to other libraries.

The following library called {\cf (hello)} exports a definition called
{\cf hello-world},  and imports the base library (see
chapter~\ref{baselibrarychapter}) and the simple I/O library (see
library section~\extref{lib:simpleiosection}{Simple I/O}).  The {\cf
  hello-world} export is a procedure that displays {\cf Hello World}
on a separate line:
%
\begin{scheme}
(library (hello)
  (export hello-world)
  (import (rnrs base)
          (rnrs io simple))
  (define (hello-world)
    (display "Hello World")
    (newline)))%
\end{scheme}

\section{Top-level programs}

A Scheme program is invoked via a \textit{top-level
  program}\index{top-level program}.  Like a library, a top-level
program contains imports, definitions and expressions, and specifies
an entry point for execution.  Thus a top-level program defines, via
the transitive closure of the libraries it imports, a Scheme program.

The following top-level program obtains the first argument from the command line
via the {\cf command-line} procedure from the \rsixlibrary{programs}
library (see library chapter~\extref{lib:programlibchapter}{Command-line
  access and exit values}).  It then opens the file using {\cf
  open-file-input-port} (see library section~\extref{lib:portsiosection}),
yielding a \textit{port}, i.e.\ a connection to the file as a data
source, and calls the {\cf get-bytes-all} procedure to obtain the
contents of the file as binary data.  It then uses {\cf put-bytes} to
output the contents of the file to standard output:
%
\begin{scheme}
\#!r6rs
(import (rnrs base)
        (rnrs io ports)
        (rnrs programs))
(put-bytes (standard-output-port)
           (call-with-port
               (open-file-input-port
                 (cadr (command-line)))
             get-bytes-all))%
\end{scheme}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "r6rs"
%%% End:
